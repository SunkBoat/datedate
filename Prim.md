　　Prim算法采用与Dijkstra、Bellman-Ford算法一样的“蓝白点”思想：白点代表已经进入最小生成树的点，蓝点代表未进入最小生成树的点。
算法描述：
以1为起点生成最小生成树，min[v]表示蓝点v与白点相连的最小边权。
MST表示最小生成树的权值之和。
a）初始化：min[v]= ∞(v≠1); min[1]=0;MST=0;
b）for (i = 1; i<= n; i++)
1.寻找min[u]最小的蓝点u。
2.将u标记为白点
3.MST+=min[u]
4.for 与白点u相连的所有蓝点v  
                 if (w[u][v]<min[v]) 
                      min[v]=w[u][v];
c）算法结束： MST即为最小生成树的权值之和

算法分析&思想讲解：
    Prim算法每次循环都将一个蓝点u变为白点，并且此蓝点u与白点相连的最小边权min[u]还是当前所有蓝点中最小的。这样相当于向生成树中添加了n-1次最小的边，最后得到的一定是最小生成树。
　　我们通过对下图最小生成树的求解模拟来理解上面的思想。蓝点和虚线代表未进入最小生成树的点、边；白点和实线代表已进入最小生成树的点、边。


初始时所有点都是蓝点，min[1]=0,min[2、3、4、5]=∞。权值之和MST=0。
第一次循环自然是找到min[1]=0最小的蓝点1。将1变为白点，接着枚举与1相连的所有蓝点2、3、4，修改它们与白点相连的最小边权。

第二次循环是找到min[2]最小的蓝点2。将2变为白点，接着枚举与2相连的所有蓝点3、5，修改它们与白点相连的最小边权。
　　
第三次循环是找到min[3]最小的蓝点3。将3变为白点，接着枚举与3相连的所有蓝点4、5，修改它们与白点相连的最小边权。
　　
